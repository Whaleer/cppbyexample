# C++ by Example 网页生成原理

## 目录

1. [项目概述](#项目概述)
2. [源码结构](#源码结构)
3. [构建流程](#构建流程)
4. [HTML 生成核心](#html-生成核心)
5. [代码解析与渲染](#代码解析与渲染)
6. [模板系统](#模板系统)
7. [本地预览](#本地预览)
8. [发布部署](#发布部署)

---

## 项目概述

C++ by Example 是一个基于 Go by Example 构建的 C++ 语言学习网站，它通过 Go 工具链将带注释的 C++ 示例代码自动生成为静态 HTML 网页。

### 核心技术栈

| 技术 | 用途 |
|------|------|
| Go 1.18 | 主要构建语言 |
| Chroma | 代码语法高亮 |
| Blackfriday | Markdown 转 HTML |
| Go Template | HTML 模板渲染 |
| S3 | 静态网站托管 |

### 目录结构

```
cppbyexample/
├── examples/           # 示例源码（每个示例一个子目录）
│   └── hello-world/
│       ├── hello-world.cpp  # C++ 源码
│       └── hello-world.sh   # Shell 输出示例
├── templates/          # HTML 模板
│   ├── index.tmpl      # 首页模板
│   ├── example.tmpl    # 示例页模板
│   ├── 404.tmpl        # 404 页模板
│   └── footer.tmpl     # 公共页脚
├── tools/             # 构建工具（Go 脚本）
│   ├── generate.go     # HTML 生成核心
│   ├── serve.go        # 本地预览服务器
│   ├── upload.go       # S3 上传工具
│   ├── build           # 构建脚本
│   ├── test            # 代码测试
│   ├── format          # 代码格式化
│   └── measure         # 行长度检查
├── public/            # 生成的静态网站（不提交）
└── examples.txt       # 导航顺序定义
```

---

## 源码结构

### 示例文件组织

每个示例位于 `examples/<example-name>/` 目录下，包含：

- `<example-name>.cpp` - 带注释的 C++ 源码
- `<example-name>.sh`（可选）- Shell 命令和输出示例

### examples.txt 导航配置

`examples.txt` 定义了示例的显示顺序：

```
Hello World
```

### 源码格式规范

示例文件采用**交替注释**和**代码块**的格式：

```cpp
// 这是注释（文档）
int x = 42;  // 这是代码
// 这是更多注释
int y = 100; // 这是更多代码
```

注释使用 `//` 前缀，生成器会自动识别并分离文档和代码段。

---

## 构建流程

### tools/build 脚本

构建流程是完整的四阶段流水线：

```bash
#!/usr/bin/env bash
set -e

verbose && echo "Running tests..."
tools/test

verbose && echo "Formatting code..."
tools/format

verbose && echo "Measuring line lengths..."
tools/measure

SITE_DIR="public"
GENERATE_DIR="$(mktemp -d)"

verbose && echo "Generating HTML to $GENERATE_DIR..."
tools/generate $GENERATE_DIR

verbose && echo "Copying $GENERATE_DIR to $SITE_DIR"
cp -rf "${GENERATE_DIR}/." "$SITE_DIR"
```

### 四个阶段详解

| 阶段 | 命令 | 作用 |
|------|------|------|
| 1. 测试 | `tools/test` | 使用 g++ -fsyntax-only 检查所有示例是否可编译 |
| 2. 格式化 | `tools/format` | 使用 clang-format 格式化所有 .cpp 文件 |
| 3. 行长检查 | `tools/measure` | 检查非注释代码行是否超过 58 字符 |
| 4. HTML 生成 | `tools/generate` | 生成完整的静态网站 |

### 执行命令

```bash
# 完整构建
tools/build

# 详细输出
VERBOSE=1 tools/build

# 测试模式（比较生成结果）
TESTING=1 tools/build
```

---

## HTML 生成核心

### tools/generate.go 架构

`generate.go` 是整个生成流程的核心，共 345 行代码，主要包含：

1. **数据结构定义** - Example 和 Seg
2. **解析器** - parseExamples() 和 parseSegs()
3. **渲染器** - renderIndex() 和 renderExamples()
4. **格式化器** - chromaFormat() 和 markdown()

### 主函数流程

```go
func main() {
    ensureDir(siteDir)
    
    // 1. 复制静态资源
    copyFile("templates/site.css", siteDir+"/site.css")
    copyFile("templates/site.js", siteDir+"/site.js")
    copyFile("templates/favicon.ico", siteDir+"/favicon.ico")
    copyFile("templates/clipboard.png", siteDir+"/clipboard.png")
    
    // 2. 解析所有示例
    examples := parseExamples()
    
    // 3. 渲染页面
    renderIndex(examples)
    renderExamples(examples)
    render404()
}
```

### 核心数据结构

#### Seg（代码段）

```go
type Seg struct {
    Docs, DocsRendered         string  // 原始文档和渲染后文档
    Code, CodeRendered          string  // 原始代码和渲染后代码
    CodeForJs                  string  // 用于 JavaScript 复制功能的代码
    CodeEmpty, CodeLeading     bool    // 标记：是否为空行、是否非最后一行
    CodeRun                    bool    // 标记：是否包含 main 函数（可运行）
}
```

#### Example（示例）

```go
type Example struct {
    ID, Name         string        // URL ID 和显示名称
    Segs             [][]*Seg      // 多个文件的代码段数组
    PrevExample      *Example      // 前一个示例（导航用）
    NextExample      *Example      // 后一个示例（导航用）
}
```

### parseExamples() 解析流程

```go
func parseExamples() []*Example {
    // 1. 读取 examples.txt
    exampleNames := readLines("examples.txt")
    
    // 2. 遍历每个示例
    for _, exampleName := range exampleNames {
        // 将名称转换为 URL ID（kebab-case）
        exampleID := strings.ToLower(exampleName)
        exampleID = strings.Replace(exampleID, " ", "-", -1)
        
        // 3. 查找示例目录下的所有文件
        sourcePaths := mustGlob("examples/" + exampleID + "/*")
        
        // 4. 解析每个文件的代码段
        for _, sourcePath := range sourcePaths {
            sourceSegs := parseAndRenderSegs(sourcePath)
            example.Segs = append(example.Segs, sourceSegs)
        }
    }
    
    // 5. 建立前后示例关系（导航）
    for i, example := range examples {
        if i > 0 { example.PrevExample = examples[i-1] }
        if i < (len(examples) - 1) { example.NextExample = examples[i+1] }
    }
    
    return examples
}
```

---

## 代码解析与渲染

### parseSegs() - 代码分段解析

这是最核心的解析逻辑，负责将源码文件拆分为文档和代码段：

```go
func parseSegs(sourcePath string) ([]*Seg, string) {
    lines := readLines(sourcePath)
    
    // 将 tab 转换为 4 空格，统一渲染
    for _, line := range lines {
        line = strings.Replace(line, "\t", "    ", -1)
    }
    
    segs := []*Seg{}
    lastSeen := ""  // 跟踪上一次是 "docs" 还是 "code"
    
    for _, line := range lines {
        if line == "" { continue }
        
        matchDocs := docsPat.MatchString(line)  // 匹配 // 注释
        matchCode := !matchDocs                 // 非注释即代码
        
        // 检测是否需要创建新段
        newDocs := (lastSeen == "") || ((lastSeen != "docs") && (segs[len(segs)-1].Docs != ""))
        newCode := (lastSeen == "") || ((lastSeen != "code") && (segs[len(segs)-1].Code != ""))
        
        if matchDocs {
            // 处理文档段
            trimmed := docsPat.ReplaceAllString(line, "")  // 移除 // 前缀
            if newDocs {
                segs = append(segs, &Seg{Docs: trimmed, Code: ""})
            } else {
                segs[len(segs)-1].Docs += "\n" + trimmed
            }
            lastSeen = "docs"
        } else if matchCode {
            // 处理代码段
            if newCode {
                segs = append(segs, &Seg{Docs: "", Code: line})
            } else {
                segs[len(segs)-1].Code += "\n" + line
            }
            lastSeen = "code"
        }
    }
    
    // 标记段属性
    for i, seg := range segs {
        seg.CodeEmpty = (seg.Code == "")
        seg.CodeLeading = (i < (len(segs) - 1))
        seg.CodeRun = strings.Contains(seg.Code, "int main")  // 可运行代码
    }
    
    return segs
}
```

### 正则表达式模式

```go
// 匹配文档行（注释行）
var docsPat = regexp.MustCompile(`^(\s*(\/\/|#|\/\*|\*)\s|\s*(\/\/|\*)$)`)

// 规范化 ID 中的连续连字符
var dashPat = regexp.MustCompile(`\-+`)
```

### chromaFormat() - 语法高亮

使用 Chroma 库进行代码高亮：

```go
func chromaFormat(code, filePath string) string {
    // 1. 获取词法分析器
    lexer := lexers.Get(filePath)
    if lexer == nil {
        lexer = lexers.Fallback
    }
    
    // 2. .sh 文件使用自定义 Shell 输出词法分析器
    if strings.HasSuffix(filePath, ".sh") {
        lexer = SimpleShellOutputLexer
    }
    
    lexer = chroma.Coalesce(lexer)
    
    // 3. 使用 swapoff 配色主题
    style := styles.Get("swapoff")
    if style == nil {
        style = styles.Fallback
    }
    
    // 4. HTML 格式化（使用 CSS 类）
    formatter := html.New(html.WithClasses(true))
    
    // 5. 词法分析并格式化
    iterator, _ := lexer.Tokenise(nil, string(code))
    buf := new(bytes.Buffer)
    formatter.Format(buf, style, iterator)
    
    return buf.String()
}
```

### 自定义 Shell 输出词法分析器

```go
var SimpleShellOutputLexer = chroma.MustNewLexer(
    &chroma.Config{
        Name:      "Shell Output",
        Aliases:   []string{"console"},
        Filenames: []string{"*.sh"},
    },
    func() chroma.Rules {
        return chroma.Rules{
            "root": {
                {`^\$`, chroma.GenericPrompt, chroma.Push("prompt")},    // $ 提示符
                {`^>`, chroma.GenericPrompt, chroma.Push("prompt")},    // > 提示符
                {`^$\n`, chroma.Text, nil},                              // 空行
                {`[^\n]+$\n?`, chroma.GenericOutput, nil},               // 输出
            },
            "prompt": {
                {`\n`, chroma.Text, chroma.Push("output")},
                {`[^\n]+$`, chroma.Text, nil},
            },
            "output": {
                {`^\$`, chroma.GenericPrompt, chroma.Pop(1)},            // 回到 prompt
                {`^>`, chroma.GenericPrompt, chroma.Pop(1)},             // 回到 prompt
                {`[^\n]+$\n?`, chroma.GenericOutput, nil},
            },
        }
    },
)
```

### parseAndRenderSegs() - 完整解析渲染

```go
func parseAndRenderSegs(sourcePath string) ([]*Seg, string) {
    // 1. 解析原始段
    segs, filecontent := parseSegs(sourcePath)
    lexer := whichLexer(sourcePath)
    
    // 2. 渲染每个段
    for _, seg := range segs {
        if seg.Docs != "" {
            // Markdown → HTML
            seg.DocsRendered = markdown(seg.Docs)
        }
        if seg.Code != "" {
            // 代码 → 高亮 HTML
            seg.CodeRendered = chromaFormat(seg.Code, sourcePath)
            
            // 为 JavaScript 准备代码（复制功能）
            if strings.HasSuffix(sourcePath, ".cpp") {
                seg.CodeForJs = strings.Trim(seg.Code, "\n") + "\n"
            }
        }
    }
    
    // 只保留 cpp 代码
    if lexer != "cpp" {
        filecontent = ""
    }
    
    return segs, filecontent
}
```

---

## 模板系统

### 模板文件结构

```
templates/
├── index.tmpl      # 首页（示例列表）
├── example.tmpl    # 示例详情页
├── 404.tmpl        # 404 错误页
└── footer.tmpl     # 公共页脚（被其他模板引用）
```

### 渲染函数

```go
func renderIndex(examples []*Example) {
    indexTmpl := template.New("index")
    template.Must(indexTmpl.Parse(mustReadFile("templates/footer.tmpl")))
    template.Must(indexTmpl.Parse(mustReadFile("templates/index.tmpl")))
    
    indexF, _ := os.Create(siteDir + "/index.html")
    defer indexF.Close()
    
    indexTmpl.Execute(indexF, examples)
}

func renderExamples(examples []*Example) {
    exampleTmpl := template.New("example")
    template.Must(exampleTmpl.Parse(mustReadFile("templates/footer.tmpl")))
    template.Must(exampleTmpl.Parse(mustReadFile("templates/example.tmpl")))
    
    for _, example := range examples {
        exampleF, _ := os.Create(siteDir + "/" + example.ID + ".html")
        defer exampleF.Close()
        
        exampleTmpl.Execute(exampleF, example)
    }
}
```

### index.tmpl（首页）

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>C++ by Example</title>
    <link rel=stylesheet href="site.css">
  </head>
  <body>
    <div id="intro">
      <h2><a href="./">C++ by Example</a></h2>
      <p>
        <a href="https://en.cppreference.com">C++</a> is an
        general-purpose programming language...
      </p>

      <p>
        <em>C++ by Example</em> is a hands-on introduction...
      </p>

      <ul>
      {{range .}}
        <li><a href="{{.ID}}.html">{{.Name}}</a></li>
      {{end}}
      </ul>
      {{ template "footer" }}
    </div>
  </body>
</html>
```

### example.tmpl（示例页）

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>C++ by Example: {{.Name}}</title>
    <link rel=stylesheet href="site.css">
  </head>
  <script>
      // 键盘导航
      onkeydown = (e) => {
          {{if .PrevExample}}
          if (e.key == "ArrowLeft") {
              window.location.href = '{{.PrevExample.ID}}.html';
          }
          {{end}}
          {{if .NextExample}}
          if (e.key == "ArrowRight") {
              window.location.href = '{{.NextExample.ID}}.html';
          }
          {{end}}
      }
  </script>
  <body>
    <div class="example" id="{{.ID}}">
      <h2><a href="./">C++ by Example</a>: {{.Name}}</h2>
      
      {{range .Segs}}
      <table>
        {{range .}}
        <tr>
          <td class="docs">
            {{.DocsRendered}}
          </td>
          <td class="code{{if .CodeEmpty}} empty{{end}}{{if .CodeLeading}} leading{{end}}">
            {{if .CodeRun}}<img title="Copy code" src="clipboard.png" class="copy" />{{end}}
            {{.CodeRendered}}
          </td>
        </tr>
        {{end}}
      </table>
      {{end}}
      
      {{if .NextExample}}
      <p class="next">
        Next example: <a href="{{.NextExample.ID}}.html">{{.NextExample.Name}}</a>.
      </p>
      {{end}}
      {{ template "footer" }}
    </div>
    
    <!-- 将代码注入 JavaScript 数组用于复制功能 -->
    <script>
      var codeLines = [];
      {{range .Segs}}{{range .}}codeLines.push('{{js .CodeForJs}}');{{end}}{{end}}
    </script>
    <script src="site.js" async></script>
  </body>
</html>
```

### footer.tmpl（公共页脚）

```html
{{define "footer"}}
    <p class="footer">
      Based on <a href="https://gobyexample.com">Go by Example</a> by <a href="https://markmcgranaghan.com">Mark McGranaghan</a> and <a href="https://eli.thegrenplace.net">Eli Bendersky</a> | <a href="https://github.com/mmcgrana/gobyexample">original source</a> | <a href="https://github.com/mmcgrana/gobyexample#license">license</a>
    </p>
{{end}}
```

### 模板数据流

```
parseExamples()
    ↓
[]*Example (包含解析后的 Segs)
    ↓
renderIndex() / renderExamples()
    ↓
Go Template Engine
    ↓
HTML 输出 (index.html, hello-world.html, etc.)
```

---

## 本地预览

### tools/serve.go HTTP 服务器

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    port := "8000"
    publicDir := "public"
    fmt.Printf("Serving Go by Example at http://127.0.0.1:%s\n", port)
    http.ListenAndServe(":"+port, http.FileServer(http.Dir(publicDir)))
}
```

### 使用方法

```bash
# 1. 生成网站
tools/build

# 2. 启动本地服务器
tools/serve

# 3. 访问
# http://127.0.0.1:8000/
```

---

## 发布部署

### S3 静态网站托管

项目使用 AWS S3 作为静态网站托管服务。

### tools/upload.go 上传流程

```go
func main() {
    // 1. 解析命令行参数
    region := flag.String("region", "", "S3 region")
    bucket := flag.String("bucket", "", "S3 bucket name")
    flag.Parse()
    
    // 2. 加载 AWS 配置
    cfg, _ := config.LoadDefaultConfig(context.TODO(), config.WithRegion(*region))
    client := s3.NewFromConfig(cfg)
    
    // 3. 读取 public/ 目录
    publicDir := "./public/"
    entries, _ := os.ReadDir(publicDir)
    
    // 4. 上传每个文件
    for _, entry := range entries {
        if !entry.IsDir() {
            file, _ := os.Open(filepath.Join(publicDir, entry.Name()))
            
            contentType := guessContentType(entry.Name())
            
            cfg := &s3.PutObjectInput{
                Bucket:      bucket,
                Key:         aws.String(entry.Name()),
                Body:        file,
                ContentType: aws.String(contentType),
            }
            
            client.PutObject(context.TODO(), cfg)
        }
    }
}
```

### 内容类型推断

```go
func guessContentType(filename string) string {
    switch filepath.Ext(filename) {
    case ".ico":
        return "image/x-icon"
    case ".png":
        return "image/png"
    case ".css":
        return "text/css"
    default:
        return "text/html"
    }
}
```

### 上传命令

```bash
# 设置 AWS 环境变量
export AWS_ACCESS_KEY_ID=your_access_key
export AWS_SECRET_ACCESS_KEY=your_secret_key

# 运行上传
go run tools/upload.go -region us-east-1 -bucket your-bucket-name
```

---

## 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                        源码准备                              │
│  examples/hello-world/hello-world.cpp                        │
│  examples/hello-world/hello-world.sh                         │
│  examples.txt                                                │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                   tools/build                                │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 1. tools/test                                       │    │
│  │    g++ -fsyntax-only 所有 .cpp 文件                 │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 2. tools/format                                     │    │
│  │    clang-format -i 所有 .cpp 文件                   │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 3. tools/measure                                    │    │
│  │    检查行长度 ≤ 58 字符                              │    │
│  └─────────────────────────────────────────────────────┘    │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                 tools/generate                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ parseExamples()                                     │    │
│  │   ├── 读取 examples.txt                             │    │
│  │   ├── 遍历每个示例目录                               │    │
│  │   └── 解析 .cpp 和 .sh 文件                         │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ parseSegs() - 分离文档和代码                        │    │
│  │   ├── 正则匹配 // 注释                               │    │
│  │   ├── 创建 Seg 结构                                 │    │
│  │   └── 标记 CodeEmpty/CodeRun                        │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 渲染                                                │    │
│  │   ├── chromaFormat() - 代码高亮                      │    │
│  │   ├── markdown() - 文档转 HTML                      │    │
│  │   └── Go Template - 注入数据                        │    │
│  └─────────────────────────────────────────────────────┘    │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                  public/ 目录                                │
│  ├── index.html              (首页)                          │
│  ├── hello-world.html        (示例页)                        │
│  ├── 404.html                                                │
│  ├── site.css                                                 │
│  ├── site.js                                                  │
│  ├── favicon.ico                                             │
│  └── clipboard.png                                            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│               tools/serve (本地预览)                          │
│           http://127.0.0.1:8000/                             │
└─────────────────────────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│               tools/upload (S3 发布)                         │
│              AWS S3 静态网站托管                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 总结

C++ by Example 的网页生成系统是一个典型的静态网站生成器，其核心特点：

1. **源码即文档** - 通过注释和代码交替的格式，将文档和代码统一管理
2. **多阶段验证** - 测试、格式化、行长检查确保代码质量
3. **模块化设计** - 解析、渲染、部署各司其职
4. **语法高亮** - Chroma 提供专业级代码高亮
5. **可扩展性** - 易于添加新示例，只需创建目录并更新 examples.txt

整个流程从 C++ 源码到静态 HTML，完全自动化，适合作为学习文档和技术网站的参考实现。
